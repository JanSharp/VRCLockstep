
- [ ] more consistently send the client joined IA... though looking at it it's already pretty consistent. I don't know how it was possible for the client joined IA to just not get run on the master, as though it wasn't even received...
- [ ] maybe handle receiving tick sync data even when we are owner of the tick sync script
- [ ] there's apparently a way for the master client to have the client state "normal"... and it makes no sense... for now I've simply added a log message in the only location where it seems like it would be possible to happen, as well as having handled OnClientJoinedIA running late
- [ ] import/export ui needs a settings button for each game state, probably in the root/main list... maybe just in every list. That'll pop up a ui next to the main UI which has game state specific settings
- [ ] maybe add option for other systems to add per client info into the info ui
- [ ] make tick timing more consistent around master changes to improve RealtimeAtTick's usefulness
- [ ] add game state safe prng
- [ ] make a tool to automatically extract autosaves and neatly arrange them in a folder, like the user's documents folder
- [x] on nth tick? game state safe.
- [x] raise event delayed by ticks, game state safe.
- [ ] ensure that any functions that previously were guaranteed to only ever run on the master are now checking if the local client is still master
- [x] ~~reconsider adding local player id to the lockstep api. It's needed like all the time~~ Reconsidered it, not adding it due to order of operation issues. The implementation would have to check if the local player variable inside of lockstep is non null before returning the cached local player id. If the local player is null then that means the start function for lockstep has not run yet, however other scripts's start functions would run before lockstep, therefore this is possible. This overall means that exposing the local player id on lockstep would come with not only the overhead of a property getter which I believe is implemented using a custom event and ultimately at least one get program variable call by UdonSharp, as well as the overhead of checking the local player variable for non null which is a branch. Udon is just too slow to warrant this. The alternative is forcing other scripts to cache their own local player id inside of their script, which removes all of this overhead, replacing it with a variable which already exists in the script that's using the variable, which is like a simple push instruction or whatever in Udon
- [x] add LockstepAPI lockstep field to LockstepGameState directly
- [x] add WriteFlags and ReadFlags with 8 overloads each, allowing to read and write up to 8 booleans
- [x] handle null ExportUI and ImportUI, because it is valid for something to support import export but not have option UIs
- [x] disable import/export buttons in game states UI until OnInit or OnClientBeginCatchUp is raised
- [x] expose current import/export options on every game state throughout the entire duration of each game state being imported/exported
- [x] use masking instead of truncate, I think that way when it does overflow you can still use the End button to get to the end of an input field, requires testing
- [x] add autosaving to game states UI again
- [ ] update notes in regards to import export options and UI events
- [x] add cloning to import export option data classes
- [ ] an option which simply disables importing a specific game state is pretty wasteful because the entire imported game state still gets sent to all clients, just for each of them to then do nothing with that data
- [x] changing the autosave interval causes the timer update loop to run twice each time it updates, and presumably 3 times if it's changed again and so on
- [x] when autosave is using export options, show all the export options in there however with the root widget's interactable set to false
  - [x] also add an info note about this in hte generic value editor as a label widget in the info fold out
- [x] apply changed autosave options upon hiding autosave window? it must apply changes at some point...
- [x] add info text to autosave generic value editor at the top about how autosaving writes to the log file
- [x] use validate functions for autosave!
- [x] add separate update function for current export options, not just get
- [x] should there be a get function for current import options?
- [x] should setting "use export options" for autosaving overwrite autosave options entirely? I think so, but that requires option data cloning
- [x] think about lifetimes for import export options...
- [x] remove all state in regards to import export UI being shown or hidden from lockstep. The functions are supposed to just be helpers for using yet another api, they should just be representing that state
- [x] game state autosave progress bar ultimately causes debug log spam due to the export options for autosave getter having a debug log, probably remove that
- [ ] probably add lockstep events for when any game state's custom import or export options UI gets shown or hidden
- [ ] in LockstepGameStatesUI in OnExportOptionsForAutosaveChanged handle other third party code using the lockstep api modifying export options for autosave, making the options saved in LockstepGameStatesUI reflect external changes. An issue here may be that we cannot compare options
  - [ ] also in OnExportOptionsForAutosaveChanged update the autosave UI if it is currently shown
  - [ ] additionally if the export window is open while OnExportOptionsForAutosaveChanged gets raised and autosave is using the same options as export then the currently shown UI should be updated, even if the export UI is currently shown, since that shares the same reference
- [x] StartImport must keep strong references to import options
- [x] ~~potentially expose MarkForOnExportOptionsForAutosaveChanged, forcing usage of the property setter to inform systems about options having changed is unintuitive~~
  - [x] instead of doing that make ExportOptionsForAutosave clone all options on both read and write, as such nothing external to lockstep may hold a reference to options used for autosaving, so long as all options's Clone function has been implemented properly - performing a deep clone rather than shallow
- [x] ~~potentially functions which decrement refs count on all export or import options~~ uhhh no, I'm not adding a wrapper for all 4 relevant wanna be class methods for export options, import options and imported game states with import options
- [x] potentially accept null as all export options for exports
- [x] add helper functions to check if any game state's custom import UI is currently shown
- [x] null options must be impossible while an options UI is shown
- [x] expose gameStatesCountSupportingExport in the lockstep api
- [x] add gameStatesSupportingImportExport both to lockstep and its api
- [x] rename cancel buttons to close, because they really don't cancel anything. They just close, just like the X
- [x] do not sort game states by them supporting import export in lockstep editor scripting
- [x] think about ValidateOptions again for import and probably also export
- [x] clear import UI and show info message about pasting exported data into the input field when opening the import UI
- [x] consecutive imports appear to make custom import options disappear, somehow
- [x] must not show import export option UIs before they're initialized - before OnInit or OnClientBeginCatchUp is raised
- [x] does the local player exist already in the client states game state at the time of OnClientBeginCatchUp being raised?
- [x] deduplicate UI updates in info UI now that latency preferences changes raise events
- [x] rate limit updating the master preference when using the slider
- [x] use the new CustomRaisedEvent attribute system for lockstep events
- [x] maybe collapse can send input actions and initialized enough for import export into one property
- [x] add flag to lockstep api indicating whether or not the current event is a game state save event
- [x] mention SendEventDelayedTicks everywhere in the docs where send input action and send singleton input action is referenced
- [x] optimize the functions using RecursiveMethod by putting all the code that won't actually be recursive into separate functions, keeping the body of the RecursiveMethods themselves smaller
- [x] add game state dependency attribute, changing the sort order of game states in the all game states array and game states supporting export array ultimately affecting serialization and deserialization order
  - [x] also force the correct load order when importing
- [ ] look at VRChat persistence
- [x] as much as I freaking hate it, change the import input field to respond to value change events 1 frame delayed. Not needed while in VRChat, but for testing in the editor this is effectively required. See also: https://vrchat.canny.io/sdk-bug-reports/p/worlds-316-vrcinputfield-inputfield-no-longer-sends-onendedit-event
- [x] add stop watches to all game state serialization and deserialization
- [x] sort game states using lowercase strings
- [ ] maybe, very much maybe, spread incoming input actions out to the next frame on master if we've already spent x ms running input actions this frame. This complicates master changes even further, because tick associations on the master are disallowed past the first mutable tick
- [ ] maybe spread input actions to be run next frame out to yet again the next frame if we've already spent x ms running input actions this frame
- [x] add checks for if we are in game state safe events inside of api functions which must be called from game state safe events, for example sending singleton input actions
- [x] change importing to just be one big input action which gets spread out across frames
- [x] maybe change importing to first read all incoming game states into separate arrays and then deserialize those one by one to prevent over-read in one game state breaking the attempt to read the next game state which makes debugging even worse, it's already bad for serialization/deserialization
- [x] change exporting to always delay 1 frame between game state serializations
- [x] handle return error messages from game state deserialization which gets spread out across frames. For LJ it might be fine as is, potentially multiple notifications, though for imports there's a property part of the lockstep api for the error message inside of the OnImportedGameState event which as it stands right now is not handled properly. That either needs to be removed, there needs to be a limitation to one error message from deserialization or idk something else
  - [x] probably the best way to handle this is to treat it as though the game state finished importing at this point, and if it flagged to continue next frame while also returning an error message that is invalid and lockstep raises an error and ignores the flag
  - [x] or ignore the error message until it's no longer flagged to continue next frame. Also a very reasonable approach
- [x] change all prefixes in debug messages in the dev folder to `[LockstepTest]`
- [x] expose read stream position
- [x] option to spread game state serialization out across frames. Except that the export api goes from nice to "oh god damn it now we need callbacks"
- [x] change gs waiting for import to an array
- [x] change import options to be send as part of the second input action, not the start import IA
- [x] ~~remove the serialized options from importedGS because it needs to be part of an input action before IsImporting gets set to true and the event for it is raised, and adding another IA to the import process makes the api worse so import options need to be part of the start import IA~~ never mind, import options data is now part of the second input action and this is required anyway because
- [x] mess with read streams so import option deserialization can start reading the associated game state already
- [x] several raise event function should not touch the is in game state safe event flag because that flag is already true when those events get raised
- [x] ~~in the deserialization docs for import options mention that it can also start deserializing the game state data itself after deserializing import options data. And then depending on the implementation it can also set the read stream position to 0 in the actual deserialization of the game state itself, depending on if the data that was deserialized got saved separately in variables or read and discarded.~~
  - [x] remove this stupid useless feature that I thought was needed for whatever reason which is import options deserialization having the ability to continue reading past its end at which point it is reading the associated game state data. This is stupid, stop it
- [x] in the info section for imports after a valid string has been pasted into the text field only list the game states which will be imported. Either
  - [x] ~~do not mention the game states which cannot be imported because they are not in the world at all~~
  - [x] ~~or put them in a fold out, which is not folded out by default~~
  - [x] show all game states in a foldout underneath the little info message about the imported data
- [x] make all the options ui apis only usable once on init or on client begin catch up have been raised
- [x] rename Export to StartExport
- [x] make sure all doc `see` references are well formed. Some have been broken due to signature changes
- [ ] if in single player, is it possible for the system to get stuck infinitely running input actions to be run in the next frame if those input actions send input actions themselves which send input actions which send input actions... infinitely? yes, quite certain this is possible. However to fix it there would need to be the option to associate input actions with the next frame even past the first mutable frame on the master, which isn't how the system is designed and trying to introduce this would even further complicate master changes and I just don't want to think about it
- [x] use System.Buffer.BlockCopy rather than System.Array.Copy... I guess?
- [x] make the lockstep master preference api actually good
- [x] add `decimal` read and write functions
- [ ] maybe add bool array read and write functions. Big maybe
- [x] try using PlayerObjects rather than cyan's player object pool. Though really... if it ain't broke don't, fix it. Only reasons I'm considering this is because it removes the need for people to add an external VCC listing manually, and to potentially improve speed of entering play mode by not having 82 instances of the InputActionSync script in the scene
  - We cannot trust PlayerObjects to be created and deleted consistently across all clients in relation to the first and last sync on the object. Lockstep requires the guarantee that any sync on an object is going to be received by all clients and I am not about to risk the integrity of the system on VRChat's internals that I cannot see, and testing it sounds like a ginormous pain and would still not guarantee that they aren't going to break it in the future. That is kind of VRChat's habit: hidden breaking changes, because everything is a breaking change
- [ ] measure input action performance overhead by sending 1 every tick, with debug logs enabled and disabled, and include the results in comparison.md
- [ ] figure out a way to make the link to online documentation automatically update when doing a release
- [x] apparently `AllClientPlayerIds`, when used inside of `OnClientBeginCatchUp`, can contain an id for a client for which `OnPreClientJoined` has not been raised yet, or `OnPreClientJoined` is getting raised on the newly joined client for a client for which `OnPreClientJoined` has already been raised before on other clients
- [x] WaitingForCandidatesLoop does not work. Master CLient A leaves. Client B has game state data, Client C does not. Client C becomes VRChat master. Client C asks all clients if they're candidates to become master, Client C determines Client B is supposed to become master, `OnAcceptedMasterCandidateIA` runs on both Client B and Client C, no client becomes master. Something along the way did not work
- [x] becoming master during the initial catch up causes it to set the last runnable tick to uint max value and it ends up trying to catch up indefinitely
- [x] becoming a new master due to the master leaving can potentially cause other clients to not run `OnMasterChangedIA` nor `OnClientLeftIA`, this is due to IAs being associated wit ha tick too early on the new master... somehow. My guess is a race condition with the tick sync script where 1 packet from that script was still in transit from the original master that had not been received on the new master yet
- [x] I noticed that there is an event for the VRChat master changing, double check and use that for the info UI
- [x] Is stopping asking for candidates really safe to do when finishing processing LJ game states?
- [ ] reduce delay for when late joiner syncing starts. Yea it will increase the amount of networking when multiple people are joining, but when just 1 or 2 people are joining it should be sending data asap
- [x] sort the clients list in the info UI please. Like please. It's such a bad look with it being undefined/unknown order. ~~Just add like a header that warns that the list is about to get reordered, a 1 or 2 second warning~~ Who cares about that warning. It really is not a big deal if the list shuffles, worst case is making the wrong player lockstep master, which can be fixed with 1 more click very quickly
- [x] info UI should have the clients list show by default, and auto switch to the notifications when there is a new one
- [x] test if scripts receive events raised by lockstep even if the scripts are disabled. The expectation is that yes they will, so add that to the docs
- [x] make info UI bigger, or at least taller
- [x] reset `sendingPlayerId`, `sendingUniqueId` and `sendingTime` after an input action handler got raised, or when early returning
- [ ] update docs to mention vrc network event changes
- [x] change "to import" to "supports import" in game state UI
- [x] add "raw: x xxx xxx bytes, base64: x xxx xxx bytes" to export UI
